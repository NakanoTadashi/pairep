import pybullet as p
import pybullet_data
import numpy as np
import random
import time
import cv2
import math

# === 迷路生成（Prim法） ===
def generate_maze(w, h):
    maze = np.zeros((h, w), dtype=int)
    start = (random.randrange(1, h, 2), random.randrange(1, w, 2))
    maze[start] = 1
    walls = [(start[0]+dy, start[1]+dx) for dx, dy in [(-2,0),(2,0),(0,-2),(0,2)]
             if 0 <= start[0]+dy < h and 0 <= start[1]+dx < w]
    while walls:
        y, x = walls.pop(random.randint(0, len(walls)-1))
        if maze[y][x] == 0:
            neighbors = [(y+dy, x+dx) for dx, dy in [(-2,0),(2,0),(0,-2),(0,2)]
                         if 0 <= y+dy < h and 0 <= x+dx < w and maze[y+dy][x+dx]==1]
            if neighbors:
                ny, nx = random.choice(neighbors)
                maze[(y+ny)//2][(x+nx)//2] = 1
                maze[y][x] = 1
                walls += [(y+dy, x+dx) for dx, dy in [(-2,0),(2,0),(0,-2),(0,2)]
                          if 0 <= y+dy < h and 0 <= x+dx < w and maze[y+dy][x+dx]==0]
    return maze

# === マップ表示 ===
def show_map(grid, current_pos):
    color_map = {
        0: (0, 0, 0),        # 壁（黒）
        1: (200, 255, 255),  # 通路（水色）
        2: (255, 0, 0),      # 現在位置（赤）
    }
    cell_size = 20
    h, w = grid.shape
    img = np.zeros((h*cell_size, w*cell_size, 3), dtype=np.uint8)
    for y in range(h):
        for x in range(w):
            val = grid[y, x]
            color = color_map.get(val, (0, 0, 0))
            cv2.rectangle(img, (x*cell_size, (h-1-y)*cell_size),
                          ((x+1)*cell_size, (h-y)*cell_size), color, -1)
    y, x = current_pos
    cv2.rectangle(img, (x*cell_size, (h-1-y)*cell_size),
                  ((x+1)*cell_size, (h-y)*cell_size), (0, 0, 255), -1)
    cv2.imshow("2D Map", img)
    cv2.waitKey(1)

# === 初期設定 ===
W, H = 11, 11
START = (1, 1)
maze = generate_maze(W, H)

p.connect(p.GUI)
p.setAdditionalSearchPath(pybullet_data.getDataPath())
p.setGravity(0, 0, -10)
p.loadURDF("plane.urdf")

# 壁の生成
for y in range(H):
    for x in range(W):
        if maze[y][x] == 0:
            p.loadURDF("cube.urdf", [x, y, 0.5], globalScaling=1)

# R2D2を配置
r2d2_id = p.loadURDF("r2d2.urdf", [START[1], START[0], 0.1])
p.resetDebugVisualizerCamera(cameraDistance=15, cameraYaw=0, cameraPitch=-89,
                             cameraTargetPosition=[W/2, H/2, 0])

# === 操作とマッピング ===
pos = START
facing = 'up'
DIRECTIONS = ['up', 'right', 'down', 'left']
DIR_VEC = {
    'up': (1, 0),     # Y+（上）
    'right': (0, 1),  # X+
    'down': (-1, 0),  # Y-（下）
    'left': (0, -1)   # X-
}
visited_map = np.zeros((H, W), dtype=int)

def get_angle(direction):
    angles = {
        'up': 0,
        'right': -math.pi / 2,
        'down': math.pi,
        'left': math.pi / 2
    }
    return angles[direction]

def rotate_right(current):
    idx = (DIRECTIONS.index(current) + 1) % 4
    return DIRECTIONS[idx]

print("↑：前進、r：右回転、ESC：終了")

# === メインループ ===
while True:
    keys = p.getKeyboardEvents()
    for k in keys:
        if keys[k] & p.KEY_WAS_TRIGGERED:
            if k == 27:  # ESC
                cv2.destroyAllWindows()
                p.disconnect()
                exit()
            elif k == ord('r'):
                facing = rotate_right(facing)
                orn = p.getQuaternionFromEuler([0, 0, get_angle(facing)])
                p.resetBasePositionAndOrientation(r2d2_id, [pos[1], pos[0], 0.1], orn)
            elif k == p.B3G_UP_ARROW:
                dy, dx = DIR_VEC[facing]
                ny, nx = pos[0] + dy, pos[1] + dx
                if 0 <= ny < H and 0 <= nx < W and maze[ny][nx] == 1:
                    visited_map[pos[0], pos[1]] = 1
                    pos = (ny, nx)
                    orn = p.getQuaternionFromEuler([0, 0, get_angle(facing)])
                    p.resetBasePositionAndOrientation(r2d2_id, [nx, ny, 0.1], orn)
    show_map(visited_map, pos)
    time.sleep(0.1)

